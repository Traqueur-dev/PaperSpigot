From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Thu, 2 Apr 2020 02:37:57 -0400
Subject: [PATCH] Optimize Collision to not load chunks

The collision code takes an AABB and generates a cuboid of checks rather
than a cylinder, so at high velocity this can generate a lot of chunk checks.

Treat an unloaded chunk as a collision for entities, and also for players if
the "prevent moving into unloaded chunks" setting is enabled.

If that serting is not enabled, collisions will be ignored for players, since
movement will load only the chunk the player enters anyways and avoids loading
massive amounts of surrounding chunks due to large AABB lookups.

diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index 461c27292af06a5150de8ec263d0c8527e8c5278..37245ff682837e7e8c9647f4afe30f0dd87cb384 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -935,6 +935,7 @@ public abstract class PlayerList {
         entityplayer1.setShiftKeyDown(false);
         entityplayer1.forceSetPositionRotation(location.getX(), location.getY(), location.getZ(), location.getYaw(), location.getPitch());
 
+        worldserver1.getChunkSource().addRegionTicket(net.minecraft.server.level.TicketType.POST_TELEPORT, new net.minecraft.world.level.ChunkPos(location.getBlockX() >> 4, location.getBlockZ() >> 4), 1, entityplayer.getId()); // Paper
         while (avoidSuffocation && !worldserver1.noCollision((Entity) entityplayer1) && entityplayer1.getY() < (double) worldserver1.getMaxBuildHeight()) {
             // CraftBukkit end
             entityplayer1.setPos(entityplayer1.getX(), entityplayer1.getY() + 1.0D, entityplayer1.getZ());
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index e6ba58cf8aef66bacdff8bf538c73b14e16fbea5..5cc7043d2783d38f9d3a28d0cb62f8834e971e1e 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -242,6 +242,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
     public org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason spawnReason; // Paper - Entity#getEntitySpawnReason
 
     public com.destroystokyo.paper.loottable.PaperLootableInventoryData lootableData; // Paper
+    public boolean collisionLoadChunks = false; // Paper
     private CraftEntity bukkitEntity;
 
     public @org.jetbrains.annotations.Nullable net.minecraft.server.level.ChunkMap.TrackedEntity tracker; // Paper
diff --git a/src/main/java/net/minecraft/world/level/BlockCollisions.java b/src/main/java/net/minecraft/world/level/BlockCollisions.java
index 1c10835b59aaefa3a65ff64f784620bdc54ddcdc..354290f88af285af229e4315e53e9bd76439d0da 100644
--- a/src/main/java/net/minecraft/world/level/BlockCollisions.java
+++ b/src/main/java/net/minecraft/world/level/BlockCollisions.java
@@ -65,35 +65,64 @@ public class BlockCollisions<T> extends AbstractIterator<T> {
 
     @Override
     protected T computeNext() {
-        while (this.cursor.advance()) {
-            int i = this.cursor.nextX();
-            int j = this.cursor.nextY();
-            int k = this.cursor.nextZ();
-            int l = this.cursor.getNextType();
-            if (l != 3) {
-                BlockGetter blockGetter = this.getChunk(i, k);
-                if (blockGetter != null) {
-                    this.pos.set(i, j, k);
-                    BlockState blockState = blockGetter.getBlockState(this.pos);
-                    if ((!this.onlySuffocatingBlocks || blockState.isSuffocating(blockGetter, this.pos))
-                        && (l != 1 || blockState.hasLargeCollisionShape())
-                        && (l != 2 || blockState.is(Blocks.MOVING_PISTON))) {
-                        VoxelShape voxelShape = blockState.getCollisionShape(this.collisionGetter, this.pos, this.context);
-                        if (voxelShape == Shapes.block()) {
-                            if (this.box.intersects((double)i, (double)j, (double)k, (double)i + 1.0, (double)j + 1.0, (double)k + 1.0)) {
-                                return this.resultProvider.apply(this.pos, voxelShape.move((double)i, (double)j, (double)k));
-                            }
-                        } else {
-                            VoxelShape voxelShape2 = voxelShape.move((double)i, (double)j, (double)k);
-                            if (!voxelShape2.isEmpty() && Shapes.joinIsNotEmpty(voxelShape2, this.entityShape, BooleanOp.AND)) {
-                                return this.resultProvider.apply(this.pos, voxelShape2);
-                            }
-                        }
+        while(true) {
+            if (this.cursor.advance()) {
+                int i = this.cursor.nextX(); final int x = i; // Paper
+                int j = this.cursor.nextY(); final int y = j; // Paper
+                int k = this.cursor.nextZ(); final int z = k; // Paper
+                int l = this.cursor.getNextType();
+                if (l == 3) {
+                    continue;
+                }
+                // Paper start - ensure we don't load chunks
+                final @Nullable Entity source = this.context instanceof net.minecraft.world.phys.shapes.EntityCollisionContext entityContext ? entityContext.getEntity() : null;
+                boolean far = source != null && io.papermc.paper.util.MCUtil.distanceSq(source.getX(), y, source.getZ(), x, y, z) > 14;
+                this.pos.set(x, y, z);
+
+                BlockState blockState;
+                if (this.collisionGetter instanceof net.minecraft.server.level.WorldGenRegion) {
+                    BlockGetter blockGetter = this.getChunk(x, z);
+                    if (blockGetter == null) {
+                       continue;
+                    }
+                    blockState = blockGetter.getBlockState(this.pos);
+                } else if ((!far && source instanceof net.minecraft.server.level.ServerPlayer) || (source != null && source.collisionLoadChunks)) {
+                    blockState = this.collisionGetter.getBlockState(this.pos);
+                } else {
+                    blockState = this.collisionGetter.getBlockStateIfLoaded(this.pos);
+                }
+
+                if (blockState == null) {
+                    if (!(source instanceof net.minecraft.server.level.ServerPlayer) || source.level().paperConfig().chunks.preventMovingIntoUnloadedChunks) {
+                        return this.resultProvider.apply(new BlockPos.MutableBlockPos(x, y, z), Shapes.create(far ? source.getBoundingBox() : new AABB(new BlockPos(x, y, z))));
+                    }
+                    // Paper end
+                    continue;
+                }
+
+                // Paper - moved up
+                if (/*this.onlySuffocatingBlocks && (!blockState.isSuffocating(blockGetter, this.pos)) ||*/ l == 1 && !blockState.hasLargeCollisionShape() || l == 2 && !blockState.is(Blocks.MOVING_PISTON)) { // Paper - onlySuffocatingBlocks is only true on the client, so we don't care about it here
+                    continue;
+                }
+
+                VoxelShape voxelShape = blockState.getCollisionShape(this.collisionGetter, this.pos, this.context);
+                if (voxelShape == Shapes.block()) {
+                    if (!this.box.intersects((double)i, (double)j, (double)k, (double)i + 1.0D, (double)j + 1.0D, (double)k + 1.0D)) {
+                        continue;
                     }
+
+                    return this.resultProvider.apply(this.pos, voxelShape.move((double)i, (double)j, (double)k));
+                }
+
+                VoxelShape voxelShape2 = voxelShape.move((double)i, (double)j, (double)k);
+                if (voxelShape2.isEmpty() || !Shapes.joinIsNotEmpty(voxelShape2, this.entityShape, BooleanOp.AND)) {
+                    continue;
                 }
+
+                return this.resultProvider.apply(this.pos, voxelShape2);
             }
-        }
 
-        return this.endOfData();
+            return this.endOfData();
+        }
     }
 }
diff --git a/src/main/java/net/minecraft/world/level/CollisionGetter.java b/src/main/java/net/minecraft/world/level/CollisionGetter.java
index 204791d893383a17b47e4c683cad3ba6c0839762..a4200e1992207e7665673c2acdb45facfd0bc676 100644
--- a/src/main/java/net/minecraft/world/level/CollisionGetter.java
+++ b/src/main/java/net/minecraft/world/level/CollisionGetter.java
@@ -44,11 +44,13 @@ public interface CollisionGetter extends BlockGetter {
     }
 
     default boolean noCollision(@Nullable Entity entity, AABB box) {
+        try { if (entity != null) entity.collisionLoadChunks = true; // Paper
         for (VoxelShape voxelShape : this.getBlockCollisions(entity, box)) {
             if (!voxelShape.isEmpty()) {
                 return false;
             }
         }
+        } finally { if (entity != null) entity.collisionLoadChunks = false; } // Paper
 
         if (!this.getEntityCollisions(entity, box).isEmpty()) {
             return false;
